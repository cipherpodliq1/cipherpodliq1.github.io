# TU-Sofia - УПР 3

Здравейте

В това упражнение ще разгледаме *Оператори за разклонения и цикли*

## Кратко съдържание
- Разработване на програми с разклонена циклична структура
- Съставяне и настройка на програми с основните видове цикли върху потокови данни
- Оператори за цикъл

# 1. Условни Оператори

В почти **всяка една програма** се срещат **условни оператори**. Те позволяват да се изпълни **определена част** от програмата (или да не се изпълни), в зависимост от това дали е изпълнено дадено условие (или не е).

Логическите изрази могат да връщат само така наречените [**булеви стойности**](https://bg.wikipedia.org/wiki/%D0%91%D1%83%D0%BB%D0%B5%D0%B2_%D1%82%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D0%B8). Тези стойности са *True* или *False*.

Тези стойности могат да се съхраняват в **променлива**:

![{10BD9050-8B27-4F17-B2F8-FFFC276F851E}](https://github.com/user-attachments/assets/b4724153-6839-4c2c-a2b3-fe08df64df0e)

![{002C66DC-59BC-4189-96DC-DFD64C315798}](https://github.com/user-attachments/assets/df824287-73fb-4e10-abd9-3daa550be8dc)

*С логическата стойност **True** могат да се интерпретират обекти, които не са празни (различни от NULL)*.

# 2. Оператори за сравнение

В **логическите изрази** се използват следните **оператори за сравнение**:

- `==` - **равно**
- `!=` - **различно**
- `<` - **по-малко**
- `>` - **по-голямо**
- `<=` - **по-малко или равно**
- `>=` - **по-голямо или равно**
- `in` - **проверява за съществуването на даден елемент**, връща **True**, ако елемента е намерен
- `is` - **проверява дали две променливи се отнасят към един и същи обект**, ако е така, връща **True**

---

## Логически Оператори

`not` - **Обръща стойността на логическия израз**, ако е бил истина, става *лъжа*, и обратното. _(Горе-долу като `!=`)_

### 3. Логическо И (`and`)

Операторът **`and`** приема **няколко условия** и връща като резултат **`True`** или **`False`**. Връща **`True`** само когато **ВСИЧКИ условия** са изпълнени.

### 4. Логическо ИЛИ (`or`)

Операторът **`or`** връща **`True`**, когато **ПОНЕ ЕДНО** от условията е **изпълнено**.

![{0634DD29-0CB3-4A4B-9E58-355131826EA5}](https://github.com/user-attachments/assets/84867a94-2b5b-4107-ab3f-1f0a6aac4345)

![{5864C56D-5289-42B9-A834-25BBF43B9876}](https://github.com/user-attachments/assets/b2ed5834-fb43-4e76-82bb-6f3e3fb0e5de)

### 5. Оператор `if-else`

Операторът **`if-else`** е **оператор за разклонение**, който позволява изпълнението на различни блокове от код в зависимост от стойността на **логическия израз**:

- **Ако изразът е `True`**, се изпълнява **един блок от код**.
- **Ако изразът е `False`**, се изпълнява **друг блок от код**.

**Синтаксисът** на `if-else` в Python е следният:

```python
if <условие>:
    # Код, който се изпълнява, ако условието е вярно (True)
    print("Условието е изпълнено!")
else:
    # Код, който се изпълнява, ако условието е невярно (False)
    print("Условието не е изпълнено!")
```

Операторът е полезен в редица случай , като например проверка на потребителски входни данни (login credentials) , проверка на статус или стойност или изпълнение на различни операции според избор на потребителя.

### 6. Оператор `elif`

Операторът **`elif`** е съкращение от **else if** и се използва за проверка на **множество условия**. В случай, че първоначалното условие в `if` не е вярно, `elif` позволява да се проверят **допълнителни условия**, без да е необходимо да се използват множество `if` блокове.

**Синтаксисът** на `elif` в Python е следният:

```python
if <условие1>:
    # Код, който се изпълнява, ако условието1 е вярно (True)
    print("Условието 1 е изпълнено!")
elif <условие2>:
    # Код, който се изпълнява, ако условието2 е вярно (True)
    print("Условието 2 е изпълнено!")
else:
    # Код, който се изпълнява, ако нито едно условие не е вярно
    print("Нито едно от условията не е изпълнено.")
```

### Примерна задача 

**Палиндром** е дума, която се чете еднакво отляво надясно и отдясно наляво. Пример за палиндром е думата "**мадам**". Ще създадем програма, която проверява дали дадена дума е палиндром, като демонстрираме използването на **`if-else`** и **`elif`** оператори.

---

#### Пример с `if-else`:

```python
word = input("Въведете дума: ")

# Превръщаме думата в малки букви за по-точна проверка
word_lower = word.lower()

if word_lower == word_lower[::-1]:
    print(f"'{word}' е палиндром.")
else:
    print(f"'{word}' не е палиндром.")
```

---

#### Обяснение:

- **Въвеждане на дума от потребителя:**
  
  Същият процес, както и при предишния пример: потребителят въвежда дума, която се съхранява в променливата `word`.

- **Преобразуване на думата в малки букви:**
  
  Отново използваме `word.lower()`, за да направим проверката нечувствителна към големината на буквите. Това е важно, защото думата "МаДам" и "мадам" трябва да се третират еднакво при проверката.

- **Проверка за дължината на думата:**
  
  Първо проверяваме дали дължината на въведената дума е по-малка или равна на 1 (`len(word) <= 1`). Ако условието е вярно, програмата отпечатва, че думата е твърде кратка, за да бъде палиндром. Тази проверка е добавена, за да се филтрират случаи, в които въведената стойност е твърде малка или празна и не представлява смислена дума.

- **Проверка дали думата е палиндром:**
  
  Ако предишното условие не е изпълнено, преминаваме към `elif` и проверяваме дали думата е палиндром, по същия начин, както в примера с `if-else`. Това става чрез сравнение на обърнатата версия на думата с оригинала (`word_lower[::-1]`).

- **Изпълнение на `else` блок:**
  
  Ако нито една от предходните проверки не е изпълнена, програмата извежда съобщение, че думата **не е палиндром**. Това е крайната възможност и означава, че думата не се чете еднакво от двете посоки.
  
---


## 7. Цикли

---

### Какво представляват циклите?

Циклите ни позволяват да **повторим изпълнението** на даден блок с код толкова пъти, колкото ни е необходимо. Този блок от код се нарича **тялото на цикъла** и може да съдържа всякакви команди, включително други вложени цикли или условни оператори.

---

### Видове цикли

В зависимост от **условието на изпълнение** и **момента на проверка**, съществуват различни видове цикли:

- **`while` цикъл** - Повтаря изпълнението на кода, докато дадено условие е вярно.
- **`for` цикъл** - Използва се за **итерация през колекции** (списъци, речници и др.) или за **бройни повторения**.
- **Безкраен цикъл** - Изпълнява се **безкрайно**, докато не бъде прекъснат с команда или външна намеса.

---

### Потенциални проблеми при използване на цикли

Трябва да сме особено внимателни с циклите, защото можем да срещнем **проблеми с безкрайно изпълнение**. Ако даден цикъл **няма правилно изходно условие** или не се променя така, че условието му да стане **невярно**, той ще се изпълнява **безкрайно**. Това може да доведе до **зацикляне на програмата**.

---

### Пример за безкраен цикъл:

```python
# Това е пример за безкраен цикъл. Не го стартирайте, защото ще блокира програмата ви!
while True:
    print("Този цикъл ще се изпълнява безкрайно, освен ако не добавим 'break' условие вътре!")
```

⚠️ Внимание!
Ваша работа е да предвидите изходно условие за този тип цикли, за да избегнете нежелано зацикляне на програмата!


## Цикъл `for`

---

### Формат на цикъла

Форматът на цикъла `for` е следният:

```python
for <елемент> in <последователност>:
    <тяло на цикъла>
```

Елемент: Променлива, чрез която ще бъде достъпен текущия елемент при обхождането.

Последователност: Обект, който може да се обхожда - низ, списък, кортеж, речник.

Тяло на цикъла: Кодът, който се изпълнява при всяка итерация на цикъла.

Следният пример демонстрира как можем да използваме цикъл for, за да отпечатаме числата от 1 до 20. За всяко нечетно число ще отпечатаме "нечетно", а за всяко четно число - "четно".

```python
for number in range(1, 21):  # Обхождаме числата от 1 до 20
    if number % 2 == 0:  # Проверяваме дали числото е четно
        print(f"{number} - четно")
    else:  # В противен случай числото е нечетно
        print(f"{number} - нечетно")
```

## Цикъл `while`

---

### Описание

При този тип цикли, тялото на цикъла се изпълнява, **докато** логическото условие е истина.

### Формат

```python
while <логически израз>:
    <тяло на цикъла>
```

Важно
В тялото на цикъла трябва да е предвидено изменение на логическия израз, в противен случай рискувате да се получи зацикляне на програмата.

Пример за използване на цикли while
Цикъл while може да бъде полезен, когато не знаем предварително колко итерации ще извършим, например при четене на вход от потребителя, докато не се получи определена стойност.

Пример
Следният код демонстрира как можем да използваме цикъл while, за да поискаме от потребителя да въведе число и да извеждаме сумата на числата, докато той не въведе 0:

### Примерен код с цикъл `while`

```python
sum = 0
number = int(input("Въведете число (или 0 за изход): "))

while number != 0:  # Продължава, докато числото не е 0
    sum += number  # Добавяме текущото число към сумата
    number = int(input("Въведете число (или 0 за изход): "))  # Искане за ново число

print(f"Сумата на числата е: {sum}")
```

Неправилен пример
```python
# Това е неправилен пример, който ще доведе до безкраен цикъл
count = 0

while count < 5:  # Условие, което никога няма да стане лъжа
    print("Този цикъл е безкраен!")
    # count не се променя, следователно условието остава вярно
```
Обяснение
В горния пример, тъй като count не се увеличава, цикълът ще продължи да се изпълнява безкрайно. За да избегнем това, трябва да добавим израз, който променя стойността на count при всяка итерация:

```python
count = 0

while count < 5:
    print("Този цикъл ще се изпълни 5 пъти.")
    count += 1  # Увеличаваме count, за да можем да излезем от цикъла
```

## Цикъл `while True` + `break`

---

### Описание

Този тип цикъл повтаря част от кода многократно, докато не се достигне до **изрично прекратяване** на цикъла, обикновено след `if` проверка в тялото на цикъла. Това е **безкраен цикъл** с проверка на дадено условие за изход вътре в тялото.

- Цикълът `while True` изпълнява своето тяло **поне веднъж**.
- Условие за прекратяване (например `break`) се проверява **вътре в тялото** на цикъла.
- При цикъла `while` проверката за изход от цикъла е в **началото**, преди неговото тяло.

---

```python
# Пример за цикъл while True + break
number = 0

while True:  # Безкраен цикъл
    if number >= 5:  # Проверка за изход
        print("Цикълът приключи.")
        break  # Прекратяване на цикъла
    
    print(f"Текущо число: {number}")
    number += 1  # Увеличаваме number с 1
```

## Оператори `break` и `continue`

---

### Оператор `break`

Операторът `break` прекъсва изпълнението на цикъла и програмата продължава с изпълнението на първата команда след тялото на цикъла. Това е полезно, когато искаме да излезем от цикъл въз основа на определено условие.

### Оператор `continue`

Операторът `continue` прекъсва текущата итерация на цикъла и осъществява преход към следващата итерация. Това означава, че кодът след `continue` в текущата итерация няма да се изпълни.

---

### Примерен код

Следният Python код отпечатва числата от 1 до 50, пропускайки четните числа:

```python
for number in range(1, 51):  # Обхождаме числата от 1 до 50
    if number % 2 == 0:  # Проверяваме дали числото е четно
        continue  # Пропускаме четните числа
    print(number)  # Отпечатваме нечетните числа
```


Задание

Създайте програма, която:

1.Проверява дали въведеното от потребителя число е положително, отрицателно или нула.
2.Отчита броя на положителните, отрицателните и нулевите числа, въведени от потребителя.
3.Изчислява и отпечатва средната стойност на всички положителни и отрицателни числа, след като потребителят реши да спре програмата с -1.
4.Проверява дали всяко число е четно или нечетно и отразява това в изхода.
5.Позволява на потребителя да въвежда числа, докато не бъдат въведени 10 числа или докато не бъде въведено -1.
6.Добавя функционалност, която проверява дали всяко положително число е по-голямо от 10, и изчислява колко от положителните числа са по-големи от 10.
7.Добавя обработка на грешки за невалидни входове.

[<< Back to Main](README.md)
